#!/usr/bin/env ruby

# This is a basic deploy script for Heroku apps.
# It provides a structure you can use to expand on
# and add your own prereqs and deploy tasks.
#
# It basically ensures that:
# 1. There are no uncommited files
# 2. You can ssh to github
# 3. You can connect to heroku
# 4. This commit is a fast forward commit to master
# 5. This HEAD hasn't been deployed to Heroku
#
# Then given all that it:
# 1. Records this commit & time in a deploys file
# 2. Commits the deploy file
# 3. Pushes to Github
# 4. Pushes to Heroku
#
# The whole process is logged to deploy.log
#
# Use:
# $ curl -s "https://raw.github.com/gist/2237714/c5b4c117014c0dfa026c7d8e8c193429b0c30a45/deploy.rb" -o script/deploy
# $ chmod +x script/deploy
# $ git add script/deploy
# $ git commit -m 'Add simple deploy script'
# $ ./script/deploy
#
# Enjoy!

require "rubygems" # ruby1.9 doesn't "require" it though
require "thor"

ROOT = File.expand_path "../../", __FILE__

LOG_FILE = "#{ROOT}/deploy.log"
DEPLOY_FILE = "#{ROOT}/deploys.md"

class Deploy < Thor
  include Thor::Actions

  class CommandFailed < StandardError ; end

  no_tasks do
    def run(command, options = {})
      `echo "#{command}" > #{LOG_FILE}`

      command = "#{command} > #{LOG_FILE} 2>&1" unless options[:capture]

      options[:verbose] ||= false

      super command, options
    end

    def run_with_status(command, options = {})
      run command, options
      $?
    end

    def success?(command, options = {})
      run_with_status(command, options).success?
    end

    def run!(command, options = {})
      raise CommandFailed, "Expected #{command} to return successfully, but didn't" unless success?(command, options)
    end

    def pass(message)
      say_status "OK", message, :green
      true
    end

    def abort_deploy(message)
      say_status "ABORT", message, :red
      say "Deploy Failed! Check log file #{LOG_FILE}"
    end

    def failure(message)
      say_status "FAIL", message, :red
      false
    end
  end

  desc "ensure_master", "Ensure on master branch"
  def ensure_master
    inside ROOT do
      branch = run "git symbolic-ref HEAD", :capture => true

      if branch =~ /master/i
        return pass "master is the current branch"
      else
        failure "Current branch is not master."
        return false
      end
    end
  end

  desc "ensure_github_connection", "Tests this user can ssh to github"
  def ensure_github_connection
    if run_with_status("ssh -T git@github.com ").exitstatus == 1
      pass "Github conencted"
    else
      failure "SSH keys missing for Github"
    end
  end

  desc "ensure_heroku_connection", "Tests this user can access heroku"
  def ensure_heroku_connection
    inside ROOT do
      remotes = run "git remote", :capture => true
      if remotes =~ /heroku/ && success?("heroku config")
        return pass "Heroku connected"
      else
        failure "SSH key missing or user is not a collabator or heroku remote is missing"
        return false
      end
    end
  end

  desc "ensure_clean", "Test to see if the repo is clean"
  def ensure_clean
    inside ROOT do
      if success? "git diff --exit-code"
        return pass "No uncommited files"
      else
        failure "There are uncommited files"
        return false
      end
    end
  end

  desc "ensure_heroku_outdated", "Test to see if this code has been deployed or not"
  def ensure_heroku_outdated
    inside ROOT do
      if !success? "git diff head heroku/master --exit-code"
        return pass "Code not deployed"
      else
        failure "Code already deployed"
        return false
      end
    end
  end

  desc "ensure_fast_forward", "Tests if this is a fast forward commit"
  def ensure_fast_forward
    inside ROOT do
      if success? "git pull origin master"
        return pass "Fast forwarded"
      else
        failure "Could not fast forward. Human required"
        run "git reset --hard HEAD"
        return false
      end
    end
  end

  desc "ensure_prereqs", "Tests all prereqs"
  def ensure_prereqs
    say "Checking prereqs..."

    prereqs = invoke(:ensure_master) &&
      invoke(:ensure_clean) &&
      invoke(:ensure_github_connection) &&
      invoke(:ensure_heroku_connection) &&
      invoke(:ensure_heroku_outdated) &&
      invoke(:ensure_fast_forward)

    if !prereqs
      abort_deploy "Failed prereqs"
      return false
    end

    pass "Prereqs"
  end

  desc "run_deploy", "Tests prereqs and runs a deploy"
  method_option :environment, :default => "production"
  def run_deploy
    prereqs = invoke(:ensure_prereqs)

    if !prereqs
      return false
    end
    say "Deploying..."

    begin
      inside ROOT do
        run! "git push origin master"
        say_status "Github", "Pushed"

        run! "git push heroku master"
        say_status "Heorku", "Deployed"
      end
    rescue CommandFailed => ex
      abort_deploy "Push failed. Please check logs."
    end
  end

  default_task :run_deploy
end

Deploy.start
